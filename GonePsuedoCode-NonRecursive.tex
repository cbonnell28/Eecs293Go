\documentclass{article}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\renewcommand{\algorithmicrequire}{\textbf{Input: }}
\renewcommand{\algorithmicensure}{\textbf{Output: }}

\begin{document}
\begin{flushleft}
Solver Class:
\end{flushleft}
\begin{itemize}
	\item Instance Variables: 
	\begin{itemize}
  		\item Board
	\end{itemize}
	\item Methods:
	\begin{itemize}
		\item solveCurrentBoard
	\end{itemize}
\end{itemize}
Board Class:
\begin{itemize}
	\item Instance Variables: 
	\begin{itemize}
  		\item 2D-Array of Pebbles
	\end{itemize}
	\item Methods:
	\begin{itemize}
		\item addPebble - add pebble to specified location on board
	\end{itemize}
\end{itemize}
Pebble Class:
\begin{itemize}
	\item Instance Variables: 
	\begin{itemize}
  		\item Color
  		\item Iteration Value
  		\item Left Pebble
  		\item Right Pebble
  		\item Up Pebble
  		\item Down Pebble
	\end{itemize}
	\item Methods:
	\begin{itemize}
		\item flipColor - if black, set Color to white, else set Color to black
	\end{itemize}
\end{itemize}

\begin{algorithm}
\caption{Solve Current Board: Belongs to Solver Class}\label{euclid}
\begin{algorithmic}[1]
\Procedure{solveCurrentBoard}{}\
\State \algorithmicrequire{A board representation that contains a 2 dimensional array of pebble representations.}\
\State \algorithmicensure{Number of iterations that pebble representations are replaced and whether or not there are any black pebble representations remaining.}
\State $\textit{Q} \gets \emptyset$ (Queue)
\State $\textit{blackPebbles} \gets 0$
\For{each $\textit{pebble}$ on board}
\If{$\textit{pebble}$ is white} 
\State {add $\textit{pebble}$ to $\textit{Q}$}
\State {set $\textit{pebble}$ iteration level to $\textit{0}$}
\Else \State {$\textit{blackPebbles}$ $\gets$ $\textit{blackPebbles}$ + 1}
\EndIf
\EndFor
\State {$\textit{currentIteration} \gets 0$}
\While {$\textit{Q}$ is not empty}
\State $\textit{currentPebble} \gets$ pebble deqeued from Q
\State {$\textit{currentIteration} \gets \textit{currentPebble}$'s $\textit{iterationLevel}$}
\State {Change color of $\textit{currentPebble}$'s black neighbors to white and enqueue them to $\textit{Q}$ with iteration level of one greater than currentPebble's iteration level.}
\State {Decrement $\textit{blackPebbles}$ by 1 for each black neighbor flipped}
\EndWhile
\State {\Return $\textit{currentPebble}$'s iteration level and True if blackPebbles $\textgreater$ 0, False otherwise}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\pagebreak
Runntime:
\begin{itemize}
\item{First loop iterates through each pebble at most once, this O(n)}
\item{Second loop goes through entirety of queue, which holds at most all the pieces on the board since pieces cannot be added to the queue more than once, this is O(n)}
\item{O(n) + O(n) = O(n), where n is the number of pieces on the board}
\end{itemize}

\end{document} 